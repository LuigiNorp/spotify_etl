{
    "sourceFile": "spotify_etl.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1646527187228,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1646528114595,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,9 +41,9 @@\n #    return True\n \n def run_spotify_etl():\n     # Scheme: postgresql://user:password@localhost:5432/database_name\n-    DATABASE_URI = open('/mnt/3E09D94559310A77/Documents/Programacion/Aprendiendo_Programacion/01_Python/01-04_Proyectos_Personales_Python/Spotify_ETL/misc/postgres_conection.txt').readline().strip()\n+    DATABASE_URI = open('/misc/postgres_conection.txt').readline().strip()\n     TOKEN = open('./misc/token.txt').readline().strip()\n     engine = create_engine(DATABASE_URI)\n     headers = {\n         'Accept': 'application/json',\n"
                }
            ],
            "date": 1646527187228,
            "name": "Commit-0",
            "content": "import pandas as pd\nimport psycopg2\nimport requests\nfrom datetime import datetime\nfrom datetime import timedelta\nimport json\nfrom sqlalchemy import create_engine\n\ndef check_if_valid_data(df: pd.DataFrame) -> bool:\n    \"\"\"\n    This function checks if DataFrame have valid data in it. 1) Check if DataFrame is empty,\n    2) Check if any primary key is repeated or not. 3) Check if the data have any null value.\n    4) Verify if the data extracted comes from the last 24 hours.\n    :param df: This is the dataframe to be checked\n    \"\"\"\n    # Check if dataframe is empty\n    if df.empty:\n        print('No songs were downloaded, Finishing execution')\n        return False\n\n    # Primary Keys\n    if pd.Series(df['played_at']).is_unique:\n        pass\n    else:\n        raise Exception('Primary key check was violated')\n\n    # Check for nulls\n    if df.isnull().values.any():\n        raise Exception('Null value found')\n\n    # Check that all data are of yesterday's date\n#    yesterday = datetime.now() - timedelta(days=1)\n#    yesterday = yesterday.replace(hour=0, minute=0, second=0, microsecond=0)\n\n#    timestamps = df['timestamp'].tolist()\n\n#    for timestamp in timestamps:\n#        if datetime.now() - datetime.strptime(timestamp, '%Y-%m-%d') > timedelta(days=1):\n#            raise Exception('At least one of the returned songs does not come from within the last 24 hours')\n\n#    return True\n\ndef run_spotify_etl():\n    # Scheme: postgresql://user:password@localhost:5432/database_name\n    DATABASE_URI = open('/mnt/3E09D94559310A77/Documents/Programacion/Aprendiendo_Programacion/01_Python/01-04_Proyectos_Personales_Python/Spotify_ETL/misc/postgres_conection.txt').readline().strip()\n    TOKEN = open('./misc/token.txt').readline().strip()\n    engine = create_engine(DATABASE_URI)\n    headers = {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json',\n        'Authorization': 'Bearer {token}'.format(token=TOKEN)\n    }\n    today = datetime.now()\n    before = today - timedelta(days=1)\n    before_unix_timestamp = int(before.timestamp()) * 1000\n\n    while True:\n        r = requests.get('https://api.spotify.com/v1/me/player/recently-played?limit=50&after={time}'.format(\n            time=before_unix_timestamp), headers=headers)\n        data = r.json()\n        if 'error' not in data:\n            break\n\n        with open('./misc/token.txt', 'w') as file:\n            # TODO: Obtain a new token automatically from Spotify API webpage\n            TOKEN = input('Please write a new token')\n            file.write(TOKEN)\n            headers = {\n                'Accept': 'application/json',\n                'Content-Type': 'application/json',\n                'Authorization': 'Bearer {token}'.format(token=TOKEN)\n            }\n            today = datetime.now()\n            before = today - timedelta(days=1)\n            before_unix_timestamp = int(before.timestamp()) * 1000\n\n    song_names = []\n    artist_names = []\n    played_at_list = []\n    timestamps = []\n\n    for song in data['items']:\n        song_names.append(song['track']['name'])\n        artist_names.append(song['track']['album']['artists'][0]['name'])\n        played_at_list.append(song['played_at'])\n        timestamps.append(song['played_at'][0:10])\n\n    song_dict = {\n        'song_name': song_names,\n        'artist_name': artist_names,\n        'played_at': played_at_list,\n        'timestamp': timestamps\n    }\n\n    song_df = pd.DataFrame(song_dict, columns=['song_name', 'artist_name', 'played_at', 'timestamp'])\n    print(song_df)\n    if check_if_valid_data(song_df):\n        print('Data valid, proceed to load stage')\n\n    song_df.to_sql('spotify_data', con=engine, if_exists='replace')\n    # song_df.to_sql('spotify_data', con=engine, if_exists='append')\n    engine.execute('SELECT * FROM public.spotify_data').fetchall()\n    print('Uploading to database completed')"
        }
    ]
}